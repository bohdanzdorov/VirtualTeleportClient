/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.3 public/models/Monitor.glb -o src/components/Monitor.jsx -r public 
*/

import React from 'react'
import { useGLTF } from '@react-three/drei'

import { useEffect, useRef, useState } from "react";
import * as THREE from "three";
import { useFrame } from "@react-three/fiber";

export function Monitor({ position, rotation, scale, stream, isActive }) {
  const { nodes, materials } = useGLTF('/models/Monitor.glb')

  const videoRef = useRef(document.createElement("video"));
  const textureRef = useRef();
  const fixedHeight = 0.24 * scale;
  const maxWidth = 0.4 * scale;  // Maximum width for video plane
  const maxHeight = fixedHeight;  // Maximum height for video plane
  const [planeSize, setPlaneSize] = useState([maxWidth, maxHeight]);

  useEffect(() => {
    const video = videoRef.current;
    if (isActive && stream) {
      video.srcObject = stream;
      video.muted = true;
      video.loop = true;
      video.playsInline = true;

      const handleLoadedMetadata = () => {
        const { videoWidth, videoHeight } = video;
        const aspect = videoWidth / videoHeight;
        let width = fixedHeight * aspect;
        // Clamp width to maxWidth to prevent video from going out of bounds
        width = Math.min(width, maxWidth);
        setPlaneSize([width, fixedHeight]);

        textureRef.current = new THREE.VideoTexture(video);
        textureRef.current.minFilter = THREE.LinearFilter;
        textureRef.current.magFilter = THREE.LinearFilter;
        textureRef.current.format = THREE.RGBAFormat;
        textureRef.current.encoding = THREE.sRGBEncoding;
        textureRef.current.needsUpdate = true;
        video.play();
      };

      video.addEventListener("loadedmetadata", handleLoadedMetadata);
      return () => video.removeEventListener("loadedmetadata", handleLoadedMetadata);
    }
  }, [stream, isActive]);

  useFrame(() => {
    if (textureRef.current && isActive) {
      textureRef.current.needsUpdate = true;
    }
  });

  return (
    <group position={position} rotation={rotation} scale={scale} dispose={null}>
      {/* Monitor frame and body */}
      <mesh geometry={nodes.computerScreen_2.geometry} material={materials.metalDark} />
      <mesh geometry={nodes.computerScreen_3.geometry} material={materials.metal} />
      <mesh geometry={nodes.computerScreen_3_1.geometry} material={materials.metalDark} />
      
      {/* Dynamic video plane for screen display */}
      <mesh position={[-0.195, 0.175, 0.05]}  rotation={[Math.PI/21, Math.PI, 0]}>
        <planeGeometry args={planeSize} />
        {isActive && textureRef.current ? (
          <meshBasicMaterial
            map={textureRef.current}
            color={0xffffff}
            transparent
            opacity={0.9}
            toneMapped={false}
            side={THREE.FrontSide}
          />
        ) : (
          <meshBasicMaterial color={"black"} opacity={0.8} transparent />
        )}
      </mesh>
    </group>
  )
}

useGLTF.preload('/models/Monitor.glb')
